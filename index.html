<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#ff4d8d" />
  <meta name="description" content="Catch hearts and avoid stars! A fun mobile game." />
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="./manifest.json" />
  
  <!-- iOS PWA Support -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="LoveME" />
  
  <title>Catch the Hearts üíñ</title>
  <style>
    :root {
      --bg: #0b1020;
      --fg: #ffffff;
      --accent: #ff4d8d;
      --good: #ff4d8d; /* heart color */
      --bad: #ffd54d;  /* star (bomb) color */
      --ui: #1a2140;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    #wrap { position: fixed; inset: 0; display: grid; grid-template-rows: 1fr auto; }
    canvas { width: 100%; height: 100%; display: block; touch-action: none; }

    /* HUD */
    #hud { position: absolute; inset: 0.75rem 0.75rem auto 0.75rem; display: flex; justify-content: space-between; gap: .5rem; pointer-events: none; }
    .badge { background: #ffffff14; backdrop-filter: blur(6px); border: 1px solid #ffffff22; border-radius: 999px; padding: .35rem .75rem; font-weight: 700; letter-spacing: .4px; }
    #pauseBtn { pointer-events: auto; background: #ffffff14; backdrop-filter: blur(6px); border: 1px solid #ffffff22; border-radius: 999px; padding: .35rem .75rem; font-weight: 700; cursor: pointer; color: var(--fg); font-size: 1.1rem; }
    #pauseBtn:hover { background: #ffffff22; }
    #pauseBtn:active { transform: scale(0.95); }

    /* Overlay (start/pause/gameover) */
    #overlay { position: absolute; inset: 0; display: grid; place-items: center; }
    .card { background: #ffffff0f; border: 1px solid #ffffff22; border-radius: 18px; padding: 1.25rem; width: min(520px, 92vw); text-align: center; box-shadow: 0 10px 30px #0006; }
    .title { font-size: clamp(22px, 3.8vw, 34px); margin: 0 0 .35rem; }
    .subtitle { margin: 0 0 1rem; opacity: .85; }
    .gameover-image { width: 100%; max-width: 300px; height: auto; border-radius: 12px; margin: 0 auto 1rem; display: block; object-fit: contain; }
    .image-text { font-size: clamp(18px, 2.5vw, 24px); font-weight: 700; margin: -0.5rem auto 1rem; color: var(--accent); text-align: center; }
    .btnbar { display: flex; gap: .6rem; flex-wrap: wrap; justify-content: center; }
    button { pointer-events: auto; background: var(--accent); color: white; border: 0; padding: .7rem 1rem; border-radius: 12px; font-weight: 700; cursor: pointer; box-shadow: 0 6px 20px #ff4d8d44; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
    button.secondary { background: var(--ui); color: #fff; box-shadow: none; border: 1px solid #ffffff22; }

    /* Mobile controls (optional) */
    #touchZones { position: absolute; inset: 0; display: none; }
    .zone { position: absolute; inset: 0 50% 0 0; }
    .zone.r { inset: 0 0 0 50%; }
    @media (max-width: 900px) {
      #touchZones { display: block; }
    }

    a { color: #a5c9ff; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" aria-label="Catch the Hearts game" role="img"></canvas>
    <div id="hud" aria-hidden="true">
      <div class="badge" id="score">Score: 0</div>
      <div style="display: flex; gap: .5rem; align-items: center;">
        <div class="badge" id="lives">Lives: 3</div>
        <button id="pauseBtn" aria-label="Pause">‚è∏Ô∏è</button>
      </div>
      <div class="badge" id="best">Best: 0</div>
    </div>
    <div id="touchZones" aria-hidden="true">
      <div class="zone l"></div>
      <div class="zone r"></div>
    </div>
    <div id="overlay">
      <div class="card">
        <h1 class="title">Catch the Hearts üíñ</h1>
        <p class="subtitle">Move left/right to catch hearts and avoid the ‚≠ê stars.</p>
        <div style="text-align:left; font-size: .95rem; line-height: 1.35; background:#ffffff0b; border:1px solid #ffffff22; border-radius:12px; padding:.8rem; margin:.7rem 0 1rem;">
          <strong>Controls</strong>
          <ul style="margin:.3rem 0 .2rem .9rem; padding:0;">
            <li><b>PC:</b> ‚Üê ‚Üí or A/D to move, <b>Space</b> to pause.</li>
            <li><b>Phone:</b> Tap/hold left or right side, or drag on the canvas.</li>
          </ul>
        </div>
        <div class="btnbar">
          <button id="playBtn">Play</button>
          <button id="muteBtn" class="secondary">üîä Sound On</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  // ===== Utility =====
  const rand = (min, max) => Math.random() * (max - min) + min;
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  // ===== Canvas setup =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // --- Drag flags must exist BEFORE any resize handlers can fire ---
  let pointerActive = false;
  let targetX = null;
  let activePointerId = null;

  // Accurate canvas sizing (accounts for iOS UI changes)
  function resizeCanvasAccurate(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const vw = Math.floor(document.documentElement.clientWidth);
    const vh = Math.floor(window.visualViewport ? window.visualViewport.height : document.documentElement.clientHeight);
    canvas.style.width = vw + 'px';
    canvas.style.height = vh + 'px';
    canvas.width = Math.floor(vw * dpr);
    canvas.height = Math.floor(vh * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }

  // While holding, avoid resizing to prevent drift (defensive if early)
  function safeResize() {
    if (typeof pointerActive !== 'undefined' && pointerActive) return;
    resizeCanvasAccurate();
  }

  window.addEventListener('resize', () => setTimeout(safeResize, 50));
  window.addEventListener('orientationchange', () => setTimeout(safeResize, 200));
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', () => setTimeout(safeResize, 50));
  }

  // ===== Game state =====
  const state = {
    running: false,
    paused: false,
    score: 0,
    lives: 3,
    best: Number(localStorage.getItem('hearts-best') || 0),
    time: 0,
    speed: 1,
    spawnAcc: 0,
    sound: true,
    mobileSpawnSlow: false,
  };

  // ===== Player =====
  const player = {
    x: 200,
    y: 0, // set on start
    w: 60,
    h: 20,
    vx: 0,
    speed: 5.2,
    color: '#a5c9ff',
  };

  // ===== Entities =====
  const hearts = [];
  const stars = [];

  // ===== Input (keys) =====
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') { togglePause(); return; }
    if (['ArrowLeft','KeyA','ArrowRight','KeyD'].includes(e.code)) e.preventDefault();
    keys.add(e.code);
  });
  window.addEventListener('keyup', (e) => keys.delete(e.code));

  // --- Direct, stable drag on canvas (pointer events + capture) ---
  function canvasXFromClient(clientX) {
    const rect = canvas.getBoundingClientRect();
    return clientX - rect.left;
  }

  canvas.addEventListener('pointerdown', (e) => {
    pointerActive = true;
    activePointerId = e.pointerId;
    canvas.setPointerCapture?.(e.pointerId);
    targetX = canvasXFromClient(e.clientX);
    e.preventDefault(); // avoid iOS gestures/scroll
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!pointerActive) return;
    if (activePointerId != null && e.pointerId !== activePointerId) return;
    targetX = canvasXFromClient(e.clientX);
    e.preventDefault();
  }, { passive: false });

  function endPointer() {
    try { if (activePointerId != null) canvas.releasePointerCapture?.(activePointerId); } catch {}
    pointerActive = false;
    activePointerId = null;
    targetX = null;
  }
  window.addEventListener('pointerup', endPointer);
  window.addEventListener('pointercancel', endPointer);

  // Touch: left/right half move zones (disabled while dragging)
  const zones = document.getElementById('touchZones');
  let touchDir = 0;
  function touchHandler(e){
    e.preventDefault();
    if (pointerActive) return; // dragging wins
    const touches = e.touches;
    touchDir = 0;
    for (let i=0;i<touches.length;i++) {
      const t = touches[i];
      const x = t.clientX;
      if (x < window.innerWidth/2) touchDir = -1; else touchDir = 1;
    }
  }
  ['touchstart','touchmove'].forEach(evt => zones.addEventListener(evt, touchHandler, {passive:false}));
  ['touchend','touchcancel'].forEach(evt => zones.addEventListener(evt, ()=>{touchDir=0;}, {passive:false}));

  // Legacy touchmove support (if pointer events missing)
  canvas.addEventListener('touchmove', (e) => {
    if (!state.running || state.paused) return;
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = t.clientX - rect.left;
    targetX = x;
    e.preventDefault();
  }, { passive: false });

  // ===== Sounds (tiny synth + HTMLAudio) =====
  let audioCtx;
  function beep(freq=660, dur=0.08, type='sine', gain=0.03){
    if (!state.sound) return;
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = gain; o.connect(g); g.connect(audioCtx.destination);
      o.start();
      setTimeout(()=>{ o.stop(); }, dur*1000);
    } catch { /* no audio */ }
  }

  // Audio unlock for iOS: run once on first gesture
  function unlockAudioOnce() {
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
    } catch {}
    try {
      const a = new Audio();
      a.src = 'data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA'; // tiny silent blip
      a.play().catch(()=>{});
    } catch {}
    window.removeEventListener('touchend', unlockAudioOnce);
    window.removeEventListener('click', unlockAudioOnce);
  }
  window.addEventListener('touchend', unlockAudioOnce, { once: true });
  window.addEventListener('click', unlockAudioOnce, { once: true });

  // HTMLAudio file player (track & stop)
  const playingAudio = [];
  function playAudioFile(filename, loop = false){
    if (!state.sound) return;
    try {
      const audio = new Audio(filename);
      audio.volume = 0.5;
      audio.loop = loop;
      playingAudio.push(audio);
      if (!loop) {
        audio.addEventListener('ended', () => {
          const index = playingAudio.indexOf(audio);
          if (index > -1) playingAudio.splice(index, 1);
        });
      }
      audio.play().catch(() => {});
    } catch {}
  }
  function stopAllAudio(){
    playingAudio.forEach(audio => {
      try {
        audio.pause();
        audio.currentTime = 0;
      } catch {}
    });
    playingAudio.length = 0;
  }

  // ===== Spawning =====
  function spawn(){
    // Spawn more slowly on mobile, ramp over time
    const base = state.mobileSpawnSlow ? 850 : 700; // ms
    const interval = Math.max(160, base - state.time * 0.03);
    state.spawnAcc += dtMs;
    if (state.spawnAcc >= interval){
      state.spawnAcc = 0;
      const starChance = Math.min(0.15 + state.time*0.00012, state.mobileSpawnSlow ? 0.35 : 0.45);
      const isStar = Math.random() < starChance;
      const x = rand(30, canvas.clientWidth-30);
      const size = rand(28, 44);
      const speed = (state.mobileSpawnSlow ? 0.75 : 0.8) + state.time*0.0003; // ramp
      if (isStar) stars.push({x, y: -40, r: size*0.45, vy: speed});
      else hearts.push({x, y: -40, size, vy: speed});
    }
  }

  // ===== Update & collisions =====
  let last = performance.now();
  let dt = 0, dtMs = 16;

  function update(){
    const now = performance.now();
    dtMs = Math.min(now - last, 40); // cap step to reduce sudden jumps
    last = now;
    dt = dtMs/16.6667; // normalize ~60fps

    if (!state.running || state.paused) return;

    state.time += dtMs;

    // Player move (direct follow when dragging; else keys/zones)
    let dir = 0;
    if (keys.has('ArrowLeft') || keys.has('KeyA')) dir -= 1;
    if (keys.has('ArrowRight') || keys.has('KeyD')) dir += 1;
    if (touchDir !== 0) dir = touchDir;

    if (pointerActive && targetX != null) {
      const clampedTarget = clamp(targetX, player.w/2 + 6, canvas.clientWidth - player.w/2 - 6);
      player.x = clampedTarget;   // direct lock under finger
      player.vx = 0;
    } else {
      player.vx = dir * player.speed;
      player.x += player.vx * dt * 3.5;
      player.x = clamp(player.x, player.w/2 + 6, canvas.clientWidth - player.w/2 - 6);
    }

    // Move entities
    for (const h of hearts) h.y += h.vy * dt * 1.8;
    for (const s of stars) s.y += s.vy * dt * 1.8;

    // Collisions with player (treat player as top edge paddle)
    const px = player.x - player.w/2, py = player.y - player.h/2;

    // Hearts
    for (let i=hearts.length-1; i>=0; i--){
      const h = hearts[i];
      if (h.y > canvas.clientHeight + 80) { hearts.splice(i,1); continue; }
      const hx = h.x, hy = h.y, r = h.size*0.42;
      if (hy + r > py && hy - r < py + player.h && Math.abs(hx - (px + player.w/2)) < (r + player.w/2)){
        hearts.splice(i,1);
        state.score += 1;
        document.getElementById('score').textContent = `Score: ${state.score}`;
        playAudioFile('./heartSound.wav'); // local asset
      }
    }

    // Stars (hurt)
    for (let i=stars.length-1; i>=0; i--){
      const s = stars[i];
      if (s.y > canvas.clientHeight + 80) { stars.splice(i,1); continue; }
      const sx = s.x, sy = s.y, r = s.r;
      if (sy + r > py && sy - r < py + player.h && Math.abs(sx - (px + player.w/2)) < (r + player.w/2)){
        stars.splice(i,1);
        loseLife();
      }
    }

    // Spawn new
    spawn();

    // Draw
    render();
    requestAnimationFrame(update);
  }

  function loseLife(){
    state.lives -= 1; document.getElementById('lives').textContent = `Lives: ${state.lives}`;
    flash('#ff4d8d'); beep(220, 0.08, 'square', 0.05);
    if (state.lives <= 0) endGame();
  }

  // ===== Rendering =====
  function render(){
    // background gradient
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const grad = ctx.createLinearGradient(0,0,0,h);
    grad.addColorStop(0, '#0b1020'); grad.addColorStop(1, '#141a34');
    ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

    // subtle stars background
    ctx.globalAlpha = 0.18; ctx.fillStyle = '#ffffff';
    for (let i=0;i<40;i++){ ctx.fillRect((i*97 + (state.time*0.02%w))%w, (i*53)%h, 2, 2); }
    ctx.globalAlpha = 1;

    // player paddle
    ctx.fillStyle = player.color;
    roundedRect(ctx, player.x - player.w/2, player.y - player.h/2, player.w, player.h, 8);
    ctx.fill();

    // entities
    for (const hrt of hearts) drawHeart(hrt.x, hrt.y, hrt.size, getComputedStyle(document.documentElement).getPropertyValue('--good').trim()||'#ff4d8d');
    for (const st of stars) drawStar(st.x, st.y, st.r, getComputedStyle(document.documentElement).getPropertyValue('--bad').trim()||'#ffd54d');
  }

  function roundedRect(ctx, x, y, w, h, r){
    ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath();
  }

  function flash(color){
    const el = document.createElement('div');
    el.style.position='absolute'; el.style.inset='0'; el.style.background=color; el.style.opacity='0.18';
    el.style.transition='opacity .28s'; document.getElementById('wrap').appendChild(el);
    requestAnimationFrame(()=>{ el.style.opacity='0'; });
    setTimeout(()=>el.remove(), 300);
  }

  // ===== Game flow =====
  const overlay = document.getElementById('overlay');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const bestEl = document.getElementById('best');
  const muteBtn = document.getElementById('muteBtn');

  muteBtn.addEventListener('click', ()=>{
    state.sound = !state.sound;
    muteBtn.textContent = state.sound ? 'üîä Sound On' : 'üîá Sound Off';
  });

  const playBtn = document.getElementById('playBtn');
  playBtn.addEventListener('click', startGame);
  playBtn.addEventListener('touchend', (e) => { e.preventDefault(); startGame(); });

  document.getElementById('pauseBtn').addEventListener('click', togglePause);

  function startGame(){
    unlockAudioOnce();              // ensure audio is unlocked on iOS
    stopAllAudio();                 // stop anything looping from prior run
    overlay.style.display='none';

    // Ensure canvas is sized properly before starting
    resizeCanvasAccurate();

    requestAnimationFrame(() => {
      resizeCanvasAccurate(); // once more after overlay hides

      state.running = true; state.paused = false; state.score = 0; state.lives = 3; state.time = 0; state.spawnAcc=0;
      scoreEl.textContent = 'Score: 0'; livesEl.textContent = 'Lives: 3'; bestEl.textContent = 'Best: ' + state.best;

      // Configure for mobile comfort
      const isMobile = canvas.clientWidth <= 820;
      state.mobileSpawnSlow = isMobile;

      // Paddle sizing
      player.w = isMobile ? Math.floor(canvas.clientWidth * 0.18) : Math.floor(canvas.clientWidth * 0.12);
      player.h = isMobile ? Math.floor(canvas.clientHeight * 0.032) : Math.floor(canvas.clientHeight * 0.026);
      player.w = Math.max(60, Math.min(120, player.w));
      player.h = Math.max(16, Math.min(26, player.h));

      // Start near bottom
      player.x = canvas.clientWidth/2;
      player.y = canvas.clientHeight - Math.max(60, canvas.clientHeight*0.08);

      hearts.length = 0; stars.length = 0; last = performance.now();
      requestAnimationFrame(update); render();
    });
  }

  function endGame(){
    state.running = false; state.paused = false;
    if (state.score > state.best){ state.best = state.score; localStorage.setItem('hearts-best', String(state.best)); }
    bestEl.textContent = 'Best: ' + state.best;
    
    // Show different image based on score
    const imageUrl = state.score >= 30 ? './happyCat.gif' : './under50.webp';
    const imageText = state.score >= 30 ? 'Yay!! You Love Meeee üéâ' : 'You Dont Love Me üò≠';

    // Play different audio based on score (loop only if >= 30)
    const audioFile = state.score >= 30 ? './happyhappy.mp3' : './gwenchana.mp3';
    const shouldLoop = state.score >= 30;
    playAudioFile(audioFile, shouldLoop);
    
    showOverlay(`Game Over ‚Äî Score ${state.score}`, `Best: ${state.best}. Tap Play to try again!`, imageUrl, imageText);
  }

  function togglePause(){
    if (!state.running) return;
    state.paused = !state.paused;
    if (state.paused) {
      showOverlay('Paused ‚è∏Ô∏è', 'Tap ‚è∏Ô∏è button or Play to resume. (PC: Press Space)', null, null);
    } else {
      overlay.style.display='none';
      last = performance.now();
      requestAnimationFrame(update);
    }
  }

  function showOverlay(title, subtitle, imageUrl = null, imageText = null){
    const imageHtml = imageUrl ? `<img src="${imageUrl}" alt="Game result" class="gameover-image" />` : '';
    const imageTextHtml = imageText ? `<p class="image-text">${imageText}</p>` : '';
    overlay.innerHTML = `
      <div class="card">
        <h1 class="title">${title}</h1>
        ${imageHtml}
        ${imageTextHtml}
        <p class="subtitle">${subtitle}</p>
        <div class="btnbar">
          <button id="playBtn2">Play</button>
          <button id="muteBtn2" class="secondary">${state.sound ? 'üîä Sound On' : 'üîá Sound Off'}</button>
        </div>
      </div>`;
    overlay.style.display='grid';
    const playBtn2 = document.getElementById('playBtn2');
    playBtn2.addEventListener('click', ()=>{ 
      overlay.style.display='none'; 
      state.paused = false;
      if (!state.running) {
        startGame();
      } else {
        last = performance.now();
        requestAnimationFrame(update);
      }
    });
    playBtn2.addEventListener('touchend', (e) => { 
      e.preventDefault();
      overlay.style.display='none'; 
      state.paused = false;
      if (!state.running) {
        startGame();
      } else {
        last = performance.now();
        requestAnimationFrame(update);
      }
    });
    document.getElementById('muteBtn2').addEventListener('click', ()=>{
      state.sound=!state.sound;
      document.getElementById('muteBtn2').textContent = state.sound ? 'üîä Sound On' : 'üîá Sound Off';
    });
  }

  // Show best on load + initial paint
  bestEl.textContent = 'Best: ' + state.best;
  resizeCanvasAccurate();
  player.x = canvas.clientWidth/2; player.y = canvas.clientHeight - 80; render();

  // Register Service Worker for PWA (scoped correctly for GitHub Pages subpath)
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js', { scope: './' })
        .then((registration) => {
          console.log('Service Worker registered:', registration);
        })
        .catch((error) => {
          console.log('Service Worker registration failed:', error);
        });
    });
  }
  </script>
</body>
</html>
